# AI智能体工作指南

## 1. 概述

本指南旨在为AI智能体提供结构化、可执行的工作框架，确保AI智能体在执行项目任务时严格遵循项目管理规范，保证工作质量和可追溯性。

## 2. 工作任务分解与优先级排序

### 2.1 任务分解原则

- **SMART原则**：任务应具备明确性(Specific)、可衡量性(Measurable)、可达成性(Achievable)、相关性(Relevant)和时限性(Time-bound)
- **模块化分解**：将复杂任务分解为独立的、可管理的模块
- **依赖关系明确**：识别任务间的依赖关系，确保按正确顺序执行

### 2.2 任务优先级排序

采用MoSCoW方法进行优先级排序：

| 优先级 | 描述 |
|--------|------|
| Must Have | 必须完成的核心任务，直接影响项目目标实现 |
| Should Have | 应该完成的重要任务，对项目有显著价值 |
| Could Have | 可以完成的次要任务，对项目有一定价值 |
| Won't Have | 暂时不会完成的任务，可推迟到后续迭代 |

### 2.3 任务示例

```markdown
# 任务列表

## Must Have
1. 实现爬虫核心功能（依赖：配置文件）
2. 实现HTML到Markdown转换（依赖：爬虫核心功能）
3. 实现图片下载功能（依赖：爬虫核心功能）

## Should Have
1. 添加日志记录功能
2. 实现断点续爬功能
3. 添加错误处理机制

## Could Have
1. 实现多线程爬取
2. 添加测试用例
3. 优化爬取速度

## Won't Have
1. 实现分布式爬取
2. 添加Web界面
```

## 3. 执行流程

### 3.1 启动阶段

1. **任务理解**：仔细阅读任务描述，明确任务目标和要求
2. **环境准备**：确保开发环境配置正确，依赖安装完整
3. **代码拉取**：从Git仓库拉取最新代码，切换到正确的分支
4. **计划制定**：使用TodoWrite工具创建详细的任务计划

### 3.2 开发阶段

1. **分支管理**：
   - 从`develop`分支创建功能分支，命名格式：`feature/功能描述`
   - 例如：`feature/implement-crawler-core`

2. **代码实现**：
   - 遵循项目的代码风格指南
   - 编写清晰、可维护的代码
   - 添加适当的注释（解释"为什么"，而不是"如何"）
   - 实现所有需求功能，处理边界情况

3. **测试**：
   - 编写单元测试，确保测试覆盖率不低于80%
   - 运行所有测试，确保测试通过
   - 进行手动测试，验证功能完整性

4. **代码审查**：
   - 提交代码到远程仓库
   - 创建Pull Request，填写完整的PR模板
   - 至少指定1名审查者
   - 根据审查反馈进行修改

### 3.3 发布阶段

1. **版本准备**：
   - 更新CHANGELOG.md文件
   - 运行所有测试，确保测试通过
   - 检查代码质量

2. **版本发布**：
   - 从develop分支创建发布分支，命名格式：`release/vX.Y.Z`
   - 合并到main分支
   - 创建版本标签：`vX.Y.Z`
   - 推送标签到远程仓库
   - 合并到develop分支
   - 删除发布分支

## 4. 工作留痕标准

### 4.1 操作记录

- **TodoWrite工具**：使用TodoWrite工具记录所有任务的执行情况，包括：
  - 任务描述
  - 状态（pending/in_progress/completed）
  - 优先级
  - 完成时间

- **命令记录**：记录所有执行的重要命令，包括：
  - 代码拉取和推送命令
  - 测试运行命令
  - 构建和部署命令

### 4.2 决策依据

- **设计文档**：记录重要的设计决策，包括：
  - 技术选型理由
  - 架构设计方案
  - 算法选择依据

- **变更记录**：记录所有重要的变更，包括：
  - 需求变更
  - 设计变更
  - 代码变更

### 4.3 中间成果文档

- **测试报告**：记录测试结果，包括：
  - 测试用例数量
  - 通过率
  - 失败原因

- **日志文件**：保留所有日志文件，包括：
  - 运行日志
  - 错误日志
  - 调试日志

- **临时文件**：保留重要的临时文件，包括：
  - 数据样本
  - 测试数据
  - 调试信息

## 5. 阶段性成果提交节点

### 5.1 每日提交

- **频率**：每日至少提交1次代码
- **内容**：当天完成的工作内容
- **提交信息**：遵循Conventional Commits规范

### 5.2 每周报告

- **频率**：每周五提交周报
- **内容**：
  - 本周完成的工作
  - 下周计划
  - 遇到的问题和解决方案
  - 需要的支持

### 5.3 里程碑提交

- **频率**：每个里程碑完成时提交
- **内容**：
  - 里程碑完成情况
  - 交付的成果物
  - 测试报告
  - 质量评估

## 6. 人工审阅触发机制及反馈响应流程

### 6.1 人工审阅触发机制

| 触发条件 | 审阅类型 | 审阅者 |
|----------|----------|--------|
| 代码提交 | 代码审查 | 至少1名团队成员 |
| Pull Request创建 | PR审查 | 至少1名团队成员 |
| 版本发布 | 版本审查 | 项目负责人 |
| 重大设计决策 | 设计审查 | 技术负责人 |
| 每周报告 | 进度审查 | 项目负责人 |

### 6.2 反馈响应流程

1. **反馈接收**：及时接收人工审阅反馈
2. **反馈分析**：分析反馈内容，理解要求和建议
3. **反馈响应**：
   - 对于需要修改的内容，制定修改计划
   - 对于有疑问的内容，及时沟通澄清
   - 对于认可的内容，确认接收
4. **修改实施**：按照修改计划进行修改
5. **修改验证**：验证修改是否符合要求
6. **反馈闭环**：将修改结果反馈给审阅者，确认问题解决

### 6.3 反馈响应时间

- 对于紧急反馈，应在2小时内响应
- 对于一般反馈，应在24小时内响应
- 对于复杂问题，应在48小时内给出解决方案

## 7. 代码规范

### 7.1 命名规范

- **变量名**：使用小写字母和下划线（snake_case），具有描述性
- **函数名**：使用小写字母和下划线（snake_case），动词开头
- **类名**：使用首字母大写（PascalCase）
- **模块名**：使用小写字母和下划线（snake_case）

### 7.2 代码风格

- **缩进**：使用4个空格进行缩进
- **换行**：每行不超过80个字符
- **空行**：在函数、类、逻辑块之间添加适当的空行
- **注释**：使用#添加单行注释，"""添加多行注释

### 7.3 最佳实践

- 遵循单一职责原则，每个函数/类只负责一个功能
- 避免重复代码，使用函数、类或模块复用代码
- 处理所有可能的错误，使用try-except块捕获异常
- 使用日志记录重要信息，而不是print语句
- 编写测试用例，确保代码质量

## 8. 配置管理

### 8.1 配置文件格式

- 使用JSON格式存储配置
- 配置文件命名：`功能_config.json`，例如：`crawl_config.json`
- 配置文件集中存放于`config/`目录

### 8.2 配置内容

配置文件应包含以下内容：

```json
{
  "start_url": "https://example.com",
  "max_concurrent": 5,
  "request_delay": 1,
  "output_dir": "data/markdown",
  "log_level": "INFO",
  "timeout": 30,
  "retry_count": 3
}
```

### 8.3 配置读取

使用统一的配置读取函数，确保配置的一致性和可维护性：

```python
import json
import os

def read_config(config_name):
    """读取配置文件"""
    config_path = os.path.join("config", f"{config_name}_config.json")
    with open(config_path, "r", encoding="utf-8") as f:
        return json.load(f)
```

## 9. 日志管理

### 9.1 日志格式

- 日志格式：`[时间] [级别] [模块] 消息`
- 时间格式：`YYYY-MM-DD HH:MM:SS`
- 级别：DEBUG, INFO, WARNING, ERROR, CRITICAL

### 9.2 日志配置

```python
import logging
import os

def setup_logger():
    """设置日志配置"""
    log_dir = "logs"
    os.makedirs(log_dir, exist_ok=True)
    
    logging.basicConfig(
        level=logging.INFO,
        format='[%(asctime)s] [%(levelname)s] [%(module)s] %(message)s',
        handlers=[
            logging.FileHandler(os.path.join(log_dir, 'app.log')),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger(__name__)
```

### 9.3 日志使用

- 在关键节点记录日志
- 记录重要的操作和决策
- 记录错误和异常信息
- 避免记录敏感信息

## 10. 测试管理

### 10.1 测试框架

使用pytest框架编写测试用例

### 10.2 测试文件结构

```
tests/
├── test_crawler/         # 爬虫模块测试
├── test_parser/          # 解析器模块测试
├── test_downloader/      # 下载器模块测试
└── conftest.py           # 测试配置
```

### 10.3 测试用例编写

- 测试用例应覆盖正常情况和异常情况
- 测试用例应具有描述性名称
- 测试用例应独立运行，不依赖外部资源

### 10.4 测试运行

```bash
# 运行所有测试
pytest

# 运行指定模块的测试
pytest tests/test_crawler/

# 运行指定测试用例
pytest tests/test_crawler/test_spider.py::test_get_page

# 生成测试覆盖率报告
pytest --cov=src tests/
```

## 11. 文档管理

### 11.1 文档格式

- 使用Markdown格式编写文档
- 文档文件使用描述性名称
- 文档应包含目录、标题、正文和示例

### 11.2 文档更新

- 代码变更时同步更新相关文档
- 版本发布时更新CHANGELOG.md
- 定期审查和更新文档，确保文档与实际情况一致

### 11.3 文档示例

```markdown
# 模块名称

## 1. 概述

简要描述模块的功能和用途

## 2. 功能特性

- 特性1
- 特性2
- 特性3

## 3. 使用方法

```python
# 示例代码
from module import function

result = function(param1, param2)
print(result)
```

## 4. API文档

### 4.1 函数1

```python
def function1(param1, param2):
    """
    函数描述
    
    Args:
        param1: 参数1描述
        param2: 参数2描述
    
    Returns:
        返回值描述
    
    Raises:
        ExceptionType: 异常描述
    """
```
```

## 12. 工作经验总结

### 12.1 工作流程阶段的关键经验

#### 12.1.1 环境准备与配置阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 依赖安装 | 使用`pip install -r requirements.txt`安装所有依赖 | 所有依赖安装成功，无错误提示 |
| 环境验证 | 运行基础命令验证环境 | 命令执行成功，无错误输出 |
| 目录结构检查 | 确保所有必要目录存在 | 目录结构符合设计要求，无缺失目录 |

**注意事项**：
- 依赖安装时应指定版本，避免版本冲突
- 环境验证应覆盖核心功能
- 目录结构应与项目设计保持一致

#### 12.1.2 代码开发与实现阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 代码结构设计 | 遵循模块化设计原则，分离关注点 | 代码结构清晰，职责明确 |
| 功能实现 | 按需求实现所有功能，处理边界情况 | 功能完整，无遗漏需求 |
| 代码质量 | 遵循PEP 8规范，添加适当注释 | 代码风格一致，可读性强 |
| 测试驱动开发 | 先编写测试用例，再实现功能 | 测试覆盖率不低于80% |

**注意事项**：
- 核心功能应优先实现
- 代码应具有可扩展性
- 测试用例应覆盖正常和异常情况

#### 12.1.3 测试与验证阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 单元测试 | 使用pytest框架编写和运行测试 | 所有单元测试通过 |
| 集成测试 | 测试模块间的协同工作 | 集成测试通过，无模块间冲突 |
| 端到端测试 | 测试完整的业务流程 | 端到端测试通过，业务流程完整 |
| 性能测试 | 测试系统的性能指标 | 性能符合要求，响应时间在可接受范围内 |

**注意事项**：
- 测试用例应独立运行，不依赖外部资源
- 测试结果应可复现
- 性能测试应在真实环境下进行

#### 12.1.4 文档编写与管理阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 文档结构 | 使用清晰的分级标题和编号 | 文档结构清晰，逻辑层次分明 |
| 内容完整性 | 覆盖所有必要的信息 | 文档内容完整，无缺失章节 |
| 内容准确性 | 确保文档与实际情况一致 | 文档内容准确，无错误信息 |
| 文档更新 | 代码变更时同步更新文档 | 文档与代码保持同步，无滞后 |

**注意事项**：
- 文档应定期审查和更新
- 重要文档应添加版本信息
- 文档变更应记录在CHANGELOG.md中

### 12.2 有效的工作方法

#### 12.2.1 问题分析与解决方法

| 方法名称 | 适用场景 | 实施步骤 | 预期效果 | 资源需求 |
|----------|----------|----------|----------|----------|
| 5W2H分析法 | 任务理解和需求分析 | 1. What：明确任务是什么<br>2. Why：理解为什么要做<br>3. Who：确定由谁来做<br>4. When：明确时间要求<br>5. Where：确定工作地点或环境<br>6. How：确定如何做<br>7. How much：明确资源和成本限制 | 任务理解清晰，目标明确 | 无特殊资源需求 |
| 分解-整合法 | 复杂任务处理 | 1. 分解：将复杂任务分解为多个简单子任务<br>2. 执行：逐个执行子任务<br>3. 整合：将子任务结果整合为最终成果 | 任务管理有序，进度可控 | 项目管理工具 |
| 试错法 | 技术难点突破 | 1. 提出假设<br>2. 设计实验验证假设<br>3. 分析结果，调整假设<br>4. 重复上述步骤直至问题解决 | 技术难点得到突破，积累经验 | 实验环境 |
| 对比分析法 | 代码优化和bug修复 | 1. 对比正常和异常情况<br>2. 分析差异点<br>3. 定位问题根源<br>4. 提出解决方案 | 快速定位问题，提高解决效率 | 调试工具 |

#### 12.2.2 项目管理方法

| 方法名称 | 适用场景 | 实施步骤 | 预期效果 | 资源需求 |
|----------|----------|----------|----------|----------|
| TodoWrite工具 | 任务跟踪和进度管理 | 1. 创建任务列表<br>2. 设置任务优先级和状态<br>3. 定期更新任务状态<br>4. 完成后标记任务为已完成 | 任务进度可视化，便于跟踪 | TodoWrite工具 |
| 每日站会 | 团队协作和进度同步 | 1. 汇报昨日完成工作<br>2. 计划今日工作<br>3. 提出遇到的问题<br>4. 协调资源和解决问题 | 团队信息同步，问题及时解决 | 会议时间 |
| 里程碑管理 | 项目进度控制 | 1. 确定项目里程碑<br>2. 分解里程碑为具体任务<br>3. 监控里程碑完成情况<br>4. 及时调整计划 | 项目进度可控，风险可预测 | 项目管理工具 |

#### 12.2.3 代码开发方法

| 方法名称 | 适用场景 | 实施步骤 | 预期效果 | 资源需求 |
|----------|----------|----------|----------|----------|
| 模块化开发 | 大型项目开发 | 1. 划分功能模块<br>2. 定义模块接口<br>3. 实现模块功能<br>4. 测试模块功能<br>5. 集成模块 | 代码结构清晰，可维护性强 | 无特殊资源需求 |
| 设计模式应用 | 复杂系统设计 | 1. 识别设计问题<br>2. 选择合适的设计模式<br>3. 应用设计模式实现<br>4. 验证设计效果 | 系统设计合理，可扩展性强 | 设计模式知识 |
| 代码重构 | 代码质量提升 | 1. 识别坏味道代码<br>2. 制定重构计划<br>3. 执行重构<br>4. 验证重构效果 | 代码质量提升，可维护性增强 | 重构工具 |

### 12.3 问题与解决方案对照表

#### 12.3.1 技术问题

| 问题描述 | 原因分析 | 解决步骤 | 验证方法 | 预防措施 |
|----------|----------|----------|----------|----------|
| 解析器无法定位内容区域 | 页面结构与预期不符，选择器失效 | 1. 分析页面HTML结构<br>2. 尝试多种选择器<br>3. 实现选择器降级机制 | 测试爬取多个页面，验证内容提取成功率 | 实现选择器尝试机制，支持多种选择器 |
| 未发现符合条件的链接 | 链接格式与预期不符，或使用相对链接 | 1. 分析页面链接结构<br>2. 支持相对链接解析<br>3. 扩展链接匹配规则 | 测试链接解析功能，验证链接提取成功率 | 实现灵活的链接解析规则，支持多种链接格式 |
| 图片下载失败 | 图片URL格式不正确，或网络问题 | 1. 分析图片URL格式<br>2. 实现图片URL处理逻辑<br>3. 添加重试机制 | 测试图片下载功能，验证图片下载成功率 | 实现图片URL验证和重试机制 |
| 爬取速度慢 | 单线程爬取，或请求间隔过大 | 1. 实现多线程爬取<br>2. 优化请求间隔<br>3. 使用异步IO | 测试爬取速度，验证性能提升效果 | 根据目标网站的反爬策略，调整爬取参数 |
| 内存占用过高 | 一次性处理大量数据，或内存泄漏 | 1. 实现数据流式处理<br>2. 优化内存使用<br>3. 添加内存监控 | 测试内存使用情况，验证内存占用降低效果 | 定期释放不再使用的资源，实现内存监控 |

#### 12.3.2 文档管理问题

| 问题描述 | 原因分析 | 解决步骤 | 验证方法 | 预防措施 |
|----------|----------|----------|----------|----------|
| 文档版本混乱 | 文档版本管理不规范 | 1. 制定文档版本控制规范<br>2. 为所有文档添加版本信息<br>3. 建立文档变更记录 | 检查文档版本信息，验证版本管理规范性 | 严格遵循文档版本控制规范，定期审查文档版本 |
| 文档与代码不一致 | 代码变更时未同步更新文档 | 1. 建立文档更新机制<br>2. 代码提交时检查文档更新<br>3. 定期审查文档内容 | 对比代码和文档，验证一致性 | 代码变更时同步更新相关文档，添加文档更新检查 |
| 文档查找困难 | 文档组织不合理，缺乏索引 | 1. 优化文档结构<br>2. 创建文档目录与索引<br>3. 实现文档搜索功能 | 测试文档查找效率，验证索引效果 | 建立完善的文档索引系统，定期优化文档结构 |

#### 12.3.3 项目管理问题

| 问题描述 | 原因分析 | 解决步骤 | 验证方法 | 预防措施 |
|----------|----------|----------|----------|----------|
| 任务进度滞后 | 任务分解不合理，或资源不足 | 1. 重新评估任务难度<br>2. 调整任务优先级<br>3. 增加资源投入 | 跟踪任务进度，验证进度恢复情况 | 合理分解任务，设置合理的时间估算 |
| 团队沟通不畅 | 沟通渠道不畅通，信息传递不及时 | 1. 建立定期沟通机制<br>2. 使用协作工具<br>3. 明确沟通规则 | 评估团队沟通效率，验证沟通效果 | 建立有效的沟通机制，使用合适的协作工具 |
| 质量问题频发 | 质量控制机制不完善 | 1. 建立质量控制流程<br>2. 增加测试覆盖<br>3. 实施代码审查 | 统计质量问题数量，验证质量提升效果 | 建立完善的质量控制机制，严格执行质量检查 |

## 13. 维护阶段工作指南

### 13.1 维护阶段概述

项目进入维护阶段后，主要工作包括：
- 处理人工审阅提出的新功能需求
- 进行横向扩展的调研和实现
- 修复和修正已发现的问题
- 保持系统的稳定性和可维护性

### 13.2 维护阶段工作流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│ 1. 需求接收与分析 → 2. 任务规划 → 3. 代码实现 → 4. 测试验证 → 5. 部署发布 │
└─────────────────────────────────────────────────────────────────────────┘
```

### 13.3 需求处理规范

#### 13.3.1 需求接收

- 需求来源：人工审阅者、用户反馈、系统监控
- 需求记录：使用项目管理工具或文档记录所有需求
- 需求分类：新功能需求、横向扩展需求、问题修复需求

#### 13.3.2 需求分析

- 需求理解：明确需求的目标、范围和验收标准
- 可行性评估：评估技术可行性、资源需求和时间成本
- 优先级划分：使用MoSCoW方法划分需求优先级
- 依赖关系识别：识别需求之间的依赖关系

#### 13.3.3 需求处理流程

| 需求类型 | 处理流程 | 责任人 | 时间要求 |
|----------|----------|--------|----------|
| 新功能需求 | 1. 需求分析 → 2. 设计 → 3. 实现 → 4. 测试 → 5. 发布 | AI智能体 | 视复杂度而定 |
| 横向扩展需求 | 1. 调研 → 2. 方案设计 → 3. 实现 → 4. 测试 → 5. 发布 | AI智能体 | 视复杂度而定 |
| 问题修复需求 | 1. 问题定位 → 2. 修复 → 3. 测试 → 4. 发布 | AI智能体 | 紧急问题2小时内响应，24小时内修复 |

#### 13.3.4 需求文档模板

```markdown
# 需求文档

## 1. 需求基本信息
- **需求ID**：REQ-20260103-001
- **需求名称**：实现新的文档格式支持
- **需求类型**：新功能需求
- **优先级**：Must Have
- **提出人**：人工审阅者
- **提出日期**：2026-01-03
- **预计完成日期**：2026-01-10

## 2. 需求描述
- **目标**：支持将爬取的内容转换为PDF格式
- **范围**：在现有Markdown转换功能基础上，添加PDF转换功能
- **验收标准**：成功将爬取的内容转换为PDF格式，保持格式完整性

## 3. 技术方案
- **技术选型**：使用WeasyPrint库实现HTML到PDF的转换
- **实现思路**：在现有转换流程中添加PDF转换步骤
- **资源需求**：安装WeasyPrint库

## 4. 实现计划
| 任务 | 责任人 | 预计完成时间 |
|------|--------|--------------|
| 调研WeasyPrint库 | AI智能体 | 2026-01-04 |
| 设计PDF转换模块 | AI智能体 | 2026-01-05 |
| 实现PDF转换功能 | AI智能体 | 2026-01-07 |
| 编写测试用例 | AI智能体 | 2026-01-08 |
| 测试与验证 | AI智能体 | 2026-01-09 |
| 发布 | AI智能体 | 2026-01-10 |

## 5. 风险评估
- **风险**：WeasyPrint库可能与现有依赖冲突
- **应对措施**：在测试环境中先进行兼容性测试

## 6. 验收记录
- **验收人**：人工审阅者
- **验收日期**：
- **验收结果**：
- **验收意见**：
```

### 13.4 问题修复流程

#### 13.4.1 问题接收与记录

- **问题来源**：人工审阅反馈、系统监控、用户报告
- **问题记录**：使用问题追踪工具或文档记录所有问题
- **问题分类**：bug、性能问题、安全问题、配置问题

#### 13.4.2 问题分析与定位

- **问题描述**：详细描述问题现象和复现步骤
- **日志分析**：查看相关日志，定位问题原因
- **根因分析**：使用5W2H或鱼骨图等方法分析问题根源
- **影响范围评估**：评估问题对系统的影响范围和严重程度

#### 13.4.3 问题修复流程

```
┌─────────────────────────────────────────────────────────────────────────────────────────────────┐
│ 1. 问题接收 → 2. 问题分类与优先级 → 3. 根因分析 → 4. 修复方案设计 → 5. 代码修复 → 6. 测试验证 → 7. 发布 │
└─────────────────────────────────────────────────────────────────────────────────────────────────┘
```

#### 13.4.4 问题修复优先级

| 优先级 | 严重程度 | 影响范围 | 修复时限 |
|--------|----------|----------|----------|
| P0 | 严重 | 系统崩溃、数据丢失 | 2小时内响应，24小时内修复 |
| P1 | 高 | 主要功能失效、性能严重下降 | 24小时内响应，48小时内修复 |
| P2 | 中 | 次要功能失效、轻微性能问题 | 48小时内响应，72小时内修复 |
| P3 | 低 | 界面问题、小功能改进 | 3天内响应，1周内修复 |

#### 13.4.5 问题修复文档模板

```markdown
# 问题修复报告

## 1. 问题基本信息
- **问题ID**：BUG-20260103-001
- **问题名称**：爬取内容缺失
- **问题类型**：bug
- **优先级**：P1
- **报告人**：人工审阅者
- **报告日期**：2026-01-03
- **修复完成日期**：2026-01-05

## 2. 问题描述
- **现象**：部分文档爬取后内容缺失
- **复现步骤**：爬取特定文档时出现内容缺失
- **影响范围**：特定类型的文档

## 3. 根因分析
- **日志分析**：查看爬取日志，发现部分页面的内容选择器失效
- **代码分析**：检查解析器代码，发现选择器只支持单一的内容容器
- **根因**：部分页面使用了不同的内容容器结构，导致选择器无法匹配

## 4. 修复方案
- **设计思路**：扩展内容选择器，支持多种内容容器结构
- **实现方案**：
  1. 增加多种内容选择器
  2. 实现选择器尝试机制
  3. 添加选择器优先级

## 5. 修复实施
- **修改文件**：src/crawler/parser.py
- **修改内容**：
  - 扩展了selectors列表，添加了多种内容选择器
  - 实现了选择器尝试逻辑，从高优先级到低优先级尝试
  - 添加了选择器匹配结果的验证

## 6. 测试验证
- **测试用例**：
  - 测试原问题文档，验证内容完整性
  - 测试其他文档，确保无回归问题
- **测试结果**：所有测试通过，内容缺失问题解决

## 7. 发布记录
- **发布版本**：v1.1.0
- **发布日期**：2026-01-05
- **发布方式**：增量发布

## 8. 预防措施
- 增强选择器的灵活性和鲁棒性
- 添加内容完整性验证机制
- 增加异常处理和日志记录
```

### 13.5 维护阶段质量标准

#### 13.5.1 代码质量标准

- **代码规范**：遵循项目的代码规范（PEP 8）
- **注释覆盖率**：核心代码注释覆盖率不低于30%
- **测试覆盖率**：新增代码测试覆盖率不低于80%
- **代码复杂度**：函数圈复杂度不超过10
- **可维护性**：代码结构清晰，易于理解和修改

#### 13.5.2 功能质量标准

- **功能完整性**：所有功能按需求实现，无缺失
- **功能正确性**：功能符合预期，无逻辑错误
- **功能稳定性**：连续运行72小时无崩溃
- **性能标准**：响应时间符合要求，资源占用合理

#### 13.5.3 发布质量标准

- **测试通过**：所有测试用例通过
- **代码审查**：通过代码审查
- **文档更新**：相关文档已更新
- **变更记录**：CHANGELOG.md已更新
- **部署验证**：在测试环境验证通过

### 13.6 维护阶段最佳实践

#### 13.6.1 代码维护

- **模块化设计**：保持代码的模块化和低耦合
- **文档更新**：代码变更时同步更新相关文档
- **注释维护**：保持注释的准确性和及时性
- **代码重构**：定期进行代码重构，提高代码质量

#### 13.6.2 测试维护

- **测试用例更新**：功能变更时同步更新测试用例
- **自动化测试**：增加自动化测试覆盖
- **回归测试**：每次变更后执行回归测试
- **性能测试**：定期进行性能测试，确保系统性能

#### 13.6.3 文档维护

- **文档更新**：定期审查和更新文档
- **文档版本控制**：为文档添加版本信息
- **文档索引**：保持文档索引的准确性
- **文档一致性**：确保文档与代码、实际功能一致

#### 13.6.4 监控与日志

- **系统监控**：建立系统监控机制，及时发现问题
- **日志管理**：保持日志的完整性和可读性
- **告警机制**：设置合理的告警阈值，及时通知问题
- **日志分析**：定期分析日志，发现潜在问题

### 13.7 维护阶段经验总结

#### 13.7.1 常见问题及解决方案

| 问题类型 | 常见原因 | 解决方案 |
|----------|----------|----------|
| 功能回归 | 代码变更未充分测试 | 加强回归测试，提高测试覆盖率 |
| 性能下降 | 数据量增加或代码效率降低 | 定期进行性能测试，优化代码 |
| 配置问题 | 配置不一致或配置错误 | 建立配置管理机制，确保配置一致性 |
| 依赖冲突 | 依赖版本更新导致冲突 | 锁定依赖版本，进行兼容性测试 |

#### 13.7.2 维护阶段的持续改进

- 定期回顾和优化维护流程
- 积累和分享维护经验
- 持续改进代码质量和系统架构
- 优化测试和发布流程

## 14. 总结

本指南为AI智能体提供了结构化、可执行的工作框架，确保AI智能体在执行项目任务和维护工作时严格遵循项目管理规范，保证工作质量和可追溯性。AI智能体应始终：

- 遵循项目的代码规范和最佳实践
- 保持良好的工作习惯和沟通方式
- 及时记录工作进展和决策
- 积极响应人工审阅反馈
- 持续改进工作流程和方法
- 严格执行维护阶段的工作流程和质量标准

通过严格遵循本指南，AI智能体将能够高效、高质量地完成项目任务和维护工作，为项目的成功做出贡献。

本指南将持续更新，反映项目进展和经验积累，为AI智能体提供最新、最有效的工作指导。