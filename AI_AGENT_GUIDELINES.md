# AI智能体工作指南

## 1. 概述

本指南旨在为AI智能体提供结构化、可执行的工作框架，确保AI智能体在执行项目任务时严格遵循项目管理规范，保证工作质量和可追溯性。

## 2. 工作任务分解与优先级排序

### 2.1 任务分解原则

- **SMART原则**：任务应具备明确性(Specific)、可衡量性(Measurable)、可达成性(Achievable)、相关性(Relevant)和时限性(Time-bound)
- **模块化分解**：将复杂任务分解为独立的、可管理的模块
- **依赖关系明确**：识别任务间的依赖关系，确保按正确顺序执行

### 2.2 任务优先级排序

采用MoSCoW方法进行优先级排序：

| 优先级 | 描述 |
|--------|------|
| Must Have | 必须完成的核心任务，直接影响项目目标实现 |
| Should Have | 应该完成的重要任务，对项目有显著价值 |
| Could Have | 可以完成的次要任务，对项目有一定价值 |
| Won't Have | 暂时不会完成的任务，可推迟到后续迭代 |

### 2.3 任务示例

```markdown
# 任务列表

## Must Have
1. 实现爬虫核心功能（依赖：配置文件）
2. 实现HTML到Markdown转换（依赖：爬虫核心功能）
3. 实现图片下载功能（依赖：爬虫核心功能）

## Should Have
1. 添加日志记录功能
2. 实现断点续爬功能
3. 添加错误处理机制

## Could Have
1. 实现多线程爬取
2. 添加测试用例
3. 优化爬取速度

## Won't Have
1. 实现分布式爬取
2. 添加Web界面
```

## 3. 执行流程

### 3.1 启动阶段

1. **任务理解**：仔细阅读任务描述，明确任务目标和要求
2. **环境准备**：确保开发环境配置正确，依赖安装完整
3. **代码拉取**：从Git仓库拉取最新代码，切换到正确的分支
4. **计划制定**：使用TodoWrite工具创建详细的任务计划

### 3.2 开发阶段

1. **分支管理**：
   - 从`develop`分支创建功能分支，命名格式：`feature/功能描述`
   - 例如：`feature/implement-crawler-core`

2. **代码实现**：
   - 遵循项目的代码风格指南
   - 编写清晰、可维护的代码
   - 添加适当的注释（解释"为什么"，而不是"如何"）
   - 实现所有需求功能，处理边界情况

3. **测试**：
   - 编写单元测试，确保测试覆盖率不低于80%
   - 运行所有测试，确保测试通过
   - 进行手动测试，验证功能完整性

4. **代码审查**：
   - 提交代码到远程仓库
   - 创建Pull Request，填写完整的PR模板
   - 至少指定1名审查者
   - 根据审查反馈进行修改

### 3.3 发布阶段

1. **版本准备**：
   - 更新CHANGELOG.md文件
   - 运行所有测试，确保测试通过
   - 检查代码质量

2. **版本发布**：
   - 从develop分支创建发布分支，命名格式：`release/vX.Y.Z`
   - 合并到main分支
   - 创建版本标签：`vX.Y.Z`
   - 推送标签到远程仓库
   - 合并到develop分支
   - 删除发布分支

## 4. 工作留痕标准

### 4.1 操作记录

- **TodoWrite工具**：使用TodoWrite工具记录所有任务的执行情况，包括：
  - 任务描述
  - 状态（pending/in_progress/completed）
  - 优先级
  - 完成时间

- **命令记录**：记录所有执行的重要命令，包括：
  - 代码拉取和推送命令
  - 测试运行命令
  - 构建和部署命令

### 4.2 决策依据

- **设计文档**：记录重要的设计决策，包括：
  - 技术选型理由
  - 架构设计方案
  - 算法选择依据

- **变更记录**：记录所有重要的变更，包括：
  - 需求变更
  - 设计变更
  - 代码变更

### 4.3 中间成果文档

- **测试报告**：记录测试结果，包括：
  - 测试用例数量
  - 通过率
  - 失败原因

- **日志文件**：保留所有日志文件，包括：
  - 运行日志
  - 错误日志
  - 调试日志

- **临时文件**：保留重要的临时文件，包括：
  - 数据样本
  - 测试数据
  - 调试信息

## 5. 阶段性成果提交节点

### 5.1 每日提交

- **频率**：每日至少提交1次代码
- **内容**：当天完成的工作内容
- **提交信息**：遵循Conventional Commits规范

### 5.2 每周报告

- **频率**：每周五提交周报
- **内容**：
  - 本周完成的工作
  - 下周计划
  - 遇到的问题和解决方案
  - 需要的支持

### 5.3 里程碑提交

- **频率**：每个里程碑完成时提交
- **内容**：
  - 里程碑完成情况
  - 交付的成果物
  - 测试报告
  - 质量评估

## 6. 人工审阅触发机制及反馈响应流程

### 6.1 人工审阅触发机制

| 触发条件 | 审阅类型 | 审阅者 |
|----------|----------|--------|
| 代码提交 | 代码审查 | 至少1名团队成员 |
| Pull Request创建 | PR审查 | 至少1名团队成员 |
| 版本发布 | 版本审查 | 项目负责人 |
| 重大设计决策 | 设计审查 | 技术负责人 |
| 每周报告 | 进度审查 | 项目负责人 |

### 6.2 反馈响应流程

1. **反馈接收**：及时接收人工审阅反馈
2. **反馈分析**：分析反馈内容，理解要求和建议
3. **反馈响应**：
   - 对于需要修改的内容，制定修改计划
   - 对于有疑问的内容，及时沟通澄清
   - 对于认可的内容，确认接收
4. **修改实施**：按照修改计划进行修改
5. **修改验证**：验证修改是否符合要求
6. **反馈闭环**：将修改结果反馈给审阅者，确认问题解决

### 6.3 反馈响应时间

- 对于紧急反馈，应在2小时内响应
- 对于一般反馈，应在24小时内响应
- 对于复杂问题，应在48小时内给出解决方案

## 7. 代码规范

### 7.1 命名规范

- **变量名**：使用小写字母和下划线（snake_case），具有描述性
- **函数名**：使用小写字母和下划线（snake_case），动词开头
- **类名**：使用首字母大写（PascalCase）
- **模块名**：使用小写字母和下划线（snake_case）

### 7.2 代码风格

- **缩进**：使用4个空格进行缩进
- **换行**：每行不超过80个字符
- **空行**：在函数、类、逻辑块之间添加适当的空行
- **注释**：使用#添加单行注释，"""添加多行注释

### 7.3 最佳实践

- 遵循单一职责原则，每个函数/类只负责一个功能
- 避免重复代码，使用函数、类或模块复用代码
- 处理所有可能的错误，使用try-except块捕获异常
- 使用日志记录重要信息，而不是print语句
- 编写测试用例，确保代码质量

## 8. 配置管理

### 8.1 配置文件格式

- 使用JSON格式存储配置
- 配置文件命名：`功能_config.json`，例如：`crawl_config.json`
- 配置文件集中存放于`config/`目录

### 8.2 配置内容

配置文件应包含以下内容：

```json
{
  "start_url": "https://example.com",
  "max_concurrent": 5,
  "request_delay": 1,
  "output_dir": "data/markdown",
  "log_level": "INFO",
  "timeout": 30,
  "retry_count": 3
}
```

### 8.3 配置读取

使用统一的配置读取函数，确保配置的一致性和可维护性：

```python
import json
import os

def read_config(config_name):
    """读取配置文件"""
    config_path = os.path.join("config", f"{config_name}_config.json")
    with open(config_path, "r", encoding="utf-8") as f:
        return json.load(f)
```

## 9. 日志管理

### 9.1 日志格式

- 日志格式：`[时间] [级别] [模块] 消息`
- 时间格式：`YYYY-MM-DD HH:MM:SS`
- 级别：DEBUG, INFO, WARNING, ERROR, CRITICAL

### 9.2 日志配置

```python
import logging
import os

def setup_logger():
    """设置日志配置"""
    log_dir = "logs"
    os.makedirs(log_dir, exist_ok=True)
    
    logging.basicConfig(
        level=logging.INFO,
        format='[%(asctime)s] [%(levelname)s] [%(module)s] %(message)s',
        handlers=[
            logging.FileHandler(os.path.join(log_dir, 'app.log')),
            logging.StreamHandler()
        ]
    )
    
    return logging.getLogger(__name__)
```

### 9.3 日志使用

- 在关键节点记录日志
- 记录重要的操作和决策
- 记录错误和异常信息
- 避免记录敏感信息

## 10. 测试管理

### 10.1 测试框架

使用pytest框架编写测试用例

### 10.2 测试文件结构

```
tests/
├── test_crawler/         # 爬虫模块测试
├── test_parser/          # 解析器模块测试
├── test_downloader/      # 下载器模块测试
└── conftest.py           # 测试配置
```

### 10.3 测试用例编写

- 测试用例应覆盖正常情况和异常情况
- 测试用例应具有描述性名称
- 测试用例应独立运行，不依赖外部资源

### 10.4 测试运行

```bash
# 运行所有测试
pytest

# 运行指定模块的测试
pytest tests/test_crawler/

# 运行指定测试用例
pytest tests/test_crawler/test_spider.py::test_get_page

# 生成测试覆盖率报告
pytest --cov=src tests/
```

## 11. 文档管理

### 11.1 文档格式

- 使用Markdown格式编写文档
- 文档文件使用描述性名称
- 文档应包含目录、标题、正文和示例

### 11.2 文档更新

- 代码变更时同步更新相关文档
- 版本发布时更新CHANGELOG.md
- 定期审查和更新文档，确保文档与实际情况一致

### 11.3 文档示例

```markdown
# 模块名称

## 1. 概述

简要描述模块的功能和用途

## 2. 功能特性

- 特性1
- 特性2
- 特性3

## 3. 使用方法

```python
# 示例代码
from module import function

result = function(param1, param2)
print(result)
```

## 4. API文档

### 4.1 函数1

```python
def function1(param1, param2):
    """
    函数描述
    
    Args:
        param1: 参数1描述
        param2: 参数2描述
    
    Returns:
        返回值描述
    
    Raises:
        ExceptionType: 异常描述
    """
```
```

## 12. 工作经验总结

### 12.1 工作流程阶段的关键经验

#### 12.1.1 环境准备与配置阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 依赖安装 | 使用`pip install -r requirements.txt`安装所有依赖 | 所有依赖安装成功，无错误提示 |
| 环境验证 | 运行基础命令验证环境 | 命令执行成功，无错误输出 |
| 目录结构检查 | 确保所有必要目录存在 | 目录结构符合设计要求，无缺失目录 |

**注意事项**：
- 依赖安装时应指定版本，避免版本冲突
- 环境验证应覆盖核心功能
- 目录结构应与项目设计保持一致

#### 12.1.2 代码开发与实现阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 代码结构设计 | 遵循模块化设计原则，分离关注点 | 代码结构清晰，职责明确 |
| 功能实现 | 按需求实现所有功能，处理边界情况 | 功能完整，无遗漏需求 |
| 代码质量 | 遵循PEP 8规范，添加适当注释 | 代码风格一致，可读性强 |
| 测试驱动开发 | 先编写测试用例，再实现功能 | 测试覆盖率不低于80% |

**注意事项**：
- 核心功能应优先实现
- 代码应具有可扩展性
- 测试用例应覆盖正常和异常情况

#### 12.1.3 测试与验证阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 单元测试 | 使用pytest框架编写和运行测试 | 所有单元测试通过 |
| 集成测试 | 测试模块间的协同工作 | 集成测试通过，无模块间冲突 |
| 端到端测试 | 测试完整的业务流程 | 端到端测试通过，业务流程完整 |
| 性能测试 | 测试系统的性能指标 | 性能符合要求，响应时间在可接受范围内 |

**注意事项**：
- 测试用例应独立运行，不依赖外部资源
- 测试结果应可复现
- 性能测试应在真实环境下进行

#### 12.1.4 文档编写与管理阶段

| 核心要点 | 操作规范 | 质量标准 |
|----------|----------|----------|
| 文档结构 | 使用清晰的分级标题和编号 | 文档结构清晰，逻辑层次分明 |
| 内容完整性 | 覆盖所有必要的信息 | 文档内容完整，无缺失章节 |
| 内容准确性 | 确保文档与实际情况一致 | 文档内容准确，无错误信息 |
| 文档更新 | 代码变更时同步更新文档 | 文档与代码保持同步，无滞后 |

**注意事项**：
- 文档应定期审查和更新
- 重要文档应添加版本信息
- 文档变更应记录在CHANGELOG.md中

### 12.2 有效的工作方法

#### 12.2.1 问题分析与解决方法

| 方法名称 | 适用场景 | 实施步骤 | 预期效果 | 资源需求 |
|----------|----------|----------|----------|----------|
| 5W2H分析法 | 任务理解和需求分析 | 1. What：明确任务是什么<br>2. Why：理解为什么要做<br>3. Who：确定由谁来做<br>4. When：明确时间要求<br>5. Where：确定工作地点或环境<br>6. How：确定如何做<br>7. How much：明确资源和成本限制 | 任务理解清晰，目标明确 | 无特殊资源需求 |
| 分解-整合法 | 复杂任务处理 | 1. 分解：将复杂任务分解为多个简单子任务<br>2. 执行：逐个执行子任务<br>3. 整合：将子任务结果整合为最终成果 | 任务管理有序，进度可控 | 项目管理工具 |
| 试错法 | 技术难点突破 | 1. 提出假设<br>2. 设计实验验证假设<br>3. 分析结果，调整假设<br>4. 重复上述步骤直至问题解决 | 技术难点得到突破，积累经验 | 实验环境 |
| 对比分析法 | 代码优化和bug修复 | 1. 对比正常和异常情况<br>2. 分析差异点<br>3. 定位问题根源<br>4. 提出解决方案 | 快速定位问题，提高解决效率 | 调试工具 |

#### 12.2.2 项目管理方法

| 方法名称 | 适用场景 | 实施步骤 | 预期效果 | 资源需求 |
|----------|----------|----------|----------|----------|
| TodoWrite工具 | 任务跟踪和进度管理 | 1. 创建任务列表<br>2. 设置任务优先级和状态<br>3. 定期更新任务状态<br>4. 完成后标记任务为已完成 | 任务进度可视化，便于跟踪 | TodoWrite工具 |
| 每日站会 | 团队协作和进度同步 | 1. 汇报昨日完成工作<br>2. 计划今日工作<br>3. 提出遇到的问题<br>4. 协调资源和解决问题 | 团队信息同步，问题及时解决 | 会议时间 |
| 里程碑管理 | 项目进度控制 | 1. 确定项目里程碑<br>2. 分解里程碑为具体任务<br>3. 监控里程碑完成情况<br>4. 及时调整计划 | 项目进度可控，风险可预测 | 项目管理工具 |

#### 12.2.3 代码开发方法

| 方法名称 | 适用场景 | 实施步骤 | 预期效果 | 资源需求 |
|----------|----------|----------|----------|----------|
| 模块化开发 | 大型项目开发 | 1. 划分功能模块<br>2. 定义模块接口<br>3. 实现模块功能<br>4. 测试模块功能<br>5. 集成模块 | 代码结构清晰，可维护性强 | 无特殊资源需求 |
| 设计模式应用 | 复杂系统设计 | 1. 识别设计问题<br>2. 选择合适的设计模式<br>3. 应用设计模式实现<br>4. 验证设计效果 | 系统设计合理，可扩展性强 | 设计模式知识 |
| 代码重构 | 代码质量提升 | 1. 识别坏味道代码<br>2. 制定重构计划<br>3. 执行重构<br>4. 验证重构效果 | 代码质量提升，可维护性增强 | 重构工具 |

### 12.3 问题与解决方案对照表

#### 12.3.1 技术问题

| 问题描述 | 原因分析 | 解决步骤 | 验证方法 | 预防措施 |
|----------|----------|----------|----------|----------|
| 解析器无法定位内容区域 | 页面结构与预期不符，选择器失效 | 1. 分析页面HTML结构<br>2. 尝试多种选择器<br>3. 实现选择器降级机制 | 测试爬取多个页面，验证内容提取成功率 | 实现选择器尝试机制，支持多种选择器 |
| 未发现符合条件的链接 | 链接格式与预期不符，或使用相对链接 | 1. 分析页面链接结构<br>2. 支持相对链接解析<br>3. 扩展链接匹配规则 | 测试链接解析功能，验证链接提取成功率 | 实现灵活的链接解析规则，支持多种链接格式 |
| 图片下载失败 | 图片URL格式不正确，或网络问题 | 1. 分析图片URL格式<br>2. 实现图片URL处理逻辑<br>3. 添加重试机制 | 测试图片下载功能，验证图片下载成功率 | 实现图片URL验证和重试机制 |
| 爬取速度慢 | 单线程爬取，或请求间隔过大 | 1. 实现多线程爬取<br>2. 优化请求间隔<br>3. 使用异步IO | 测试爬取速度，验证性能提升效果 | 根据目标网站的反爬策略，调整爬取参数 |
| 内存占用过高 | 一次性处理大量数据，或内存泄漏 | 1. 实现数据流式处理<br>2. 优化内存使用<br>3. 添加内存监控 | 测试内存使用情况，验证内存占用降低效果 | 定期释放不再使用的资源，实现内存监控 |

#### 12.3.2 文档管理问题

| 问题描述 | 原因分析 | 解决步骤 | 验证方法 | 预防措施 |
|----------|----------|----------|----------|----------|
| 文档版本混乱 | 文档版本管理不规范 | 1. 制定文档版本控制规范<br>2. 为所有文档添加版本信息<br>3. 建立文档变更记录 | 检查文档版本信息，验证版本管理规范性 | 严格遵循文档版本控制规范，定期审查文档版本 |
| 文档与代码不一致 | 代码变更时未同步更新文档 | 1. 建立文档更新机制<br>2. 代码提交时检查文档更新<br>3. 定期审查文档内容 | 对比代码和文档，验证一致性 | 代码变更时同步更新相关文档，添加文档更新检查 |
| 文档查找困难 | 文档组织不合理，缺乏索引 | 1. 优化文档结构<br>2. 创建文档目录与索引<br>3. 实现文档搜索功能 | 测试文档查找效率，验证索引效果 | 建立完善的文档索引系统，定期优化文档结构 |

#### 12.3.3 项目管理问题

| 问题描述 | 原因分析 | 解决步骤 | 验证方法 | 预防措施 |
|----------|----------|----------|----------|----------|
| 任务进度滞后 | 任务分解不合理，或资源不足 | 1. 重新评估任务难度<br>2. 调整任务优先级<br>3. 增加资源投入 | 跟踪任务进度，验证进度恢复情况 | 合理分解任务，设置合理的时间估算 |
| 团队沟通不畅 | 沟通渠道不畅通，信息传递不及时 | 1. 建立定期沟通机制<br>2. 使用协作工具<br>3. 明确沟通规则 | 评估团队沟通效率，验证沟通效果 | 建立有效的沟通机制，使用合适的协作工具 |
| 质量问题频发 | 质量控制机制不完善 | 1. 建立质量控制流程<br>2. 增加测试覆盖<br>3. 实施代码审查 | 统计质量问题数量，验证质量提升效果 | 建立完善的质量控制机制，严格执行质量检查 |

## 13. 总结

本指南为AI智能体提供了结构化、可执行的工作框架，确保AI智能体在执行项目任务时严格遵循项目管理规范，保证工作质量和可追溯性。AI智能体应始终：

- 遵循项目的代码规范和最佳实践
- 保持良好的工作习惯和沟通方式
- 及时记录工作进展和决策
- 积极响应人工审阅反馈
- 持续改进工作流程和方法

通过严格遵循本指南，AI智能体将能够高效、高质量地完成项目任务，为项目的成功做出贡献。

本指南将持续更新，反映项目进展和经验积累，为AI智能体提供最新、最有效的工作指导。